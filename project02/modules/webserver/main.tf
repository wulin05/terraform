// Locate the existing default security group in this VPC, then let Terraform take over it and modify the rules.
// but in real production environment we suggest create new security group to modify the rules.
resource "aws_default_security_group" "default_myapp_sg" {
  vpc_id = var.vpc_id

  ingress {
    from_port = 22
    to_port = 22
    protocol = "tcp"
    cidr_blocks = [var.acc_security_cidr[0].cidr_block]
    description = "Library_SSH_Connection"
  }
  ingress {
    from_port = 22
    to_port = 22
    protocol = "tcp"
    cidr_blocks = [var.acc_security_cidr[1].cidr_block]
    description = "Home_SSH_Connection"
  }

  // allow any others can access this nginx server port
  ingress {
    from_port = 8080
    to_port = 8080
    protocol = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port = 0
    to_port = 0
    protocol = "-1"
    cidr_blocks = ["0.0.0.0/0"] 
    prefix_list_ids = []  
  }

  tags = {
    Name = "${var.env_prefix}-default-sg"
  }
}

/* 
// teach by chatgpt --- pro environment use
data "aws_ssm_parameter" "al2023" {
  name = "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64"
}
*/

// dynamic AMI --- teach by video
data "aws_ami" "lastest_amazon_linux_image" {
  // pro evironment strongly dispermit to use.
  most_recent = true 
  owners = [ "amazon" ]

  filter {
    name = "name"
    # values = [ "al2023-ami-*-kernel-6.1-x86_64" ]
    values = [var.image_name]
  }

  filter {
    name = "virtualization-type"
    values = [ "hvm" ]
  }

  // 不用这个会是多个AMI,这个能够只有一个AMI: al2023-ami-2023.10.20260202.2-kernel-6.1-x86_64
  name_regex = "^al2023-ami-[0-9].*-kernel-6.1-x86_64$" 
}

// if you use ssh public key by generated by local, please create this resource.
resource "aws_key_pair" "ssh_public_key" {
  key_name = "local_generate_pub_key"
  public_key = file(var.public_key_location)
}

resource "aws_instance" "myapp_server" {
  ami = data.aws_ami.lastest_amazon_linux_image.id
  instance_type = var.instance_type

  # subnet_id = aws_subnet.myapp_subnet_1.id  // 这时候就不能用aws_subnet.myapp_subnet_1.id这个了,因为aws_subnet已经被移到module/subnet/main.tf了！
  // 这个是创建了webserver的module,把这个移到这边了,所以之前在主main.tf是这么写,现在不能这么写了！
#   subnet_id = module.myapp_subnet.subnet_id
  subnet_id = var.subnet_id

  vpc_security_group_ids = [aws_default_security_group.default_myapp_sg.id]
  // availability_zone不用写,因为subnet里面已经有avail_zone的信息了：ap-northeast-1a
#   availability_zone = var.avail_zone  // as the reason above, this is not necessary.

  associate_public_ip_address = true
  # key_name = "WSL_AlmaLinux9_terraform"    // this key pair(.pem format) is created in aws plane
  key_name = aws_key_pair.ssh_public_key.key_name   // when create resource "aws_key_pair" "ssh_key", please use this method.

/*
  //一.this is bash command which can be run on the ec2 start.
  user_data = <<EOF
              #!/bin/bash
              sudo yum update -y && sudo yum install -y docker
              sudo systemctl start docker
              sudo usermod -aG docker ec2-user
              docker run -p 8080:80 nginx
            EOF
           
  //二.also, command is directly write above is not good idea,so:
  //反正：entry-script.sh写在那个main.tf里,就是要以当前main.tf作为路径的参照
  user_data = file("entry-script.sh")  与
  user_data = file("${path.module}/entry-script.sh") 
  等价！！！

  如果是entry-script.sh是在主main.tf一个层级的话,那就是：
  file("${path.root}/entry-script.sh"),  如果是在主main.tf的同级script目录下的话，就是：
  file("${path.root}/script/entry-script.sh"),  反正善用：${path.module}，${path.root} 这两个位置参数
*/
  //将下面的connction 和 provisioner 都注释掉, 极度不建议,官网也告知是 最后的手段用provisioner,所以请用user_data
  user_data = file("${path.root}/script/entry-script.sh")

  //三. provisioner can excute script after ec2 ready,but must use connection, and if network is terrible or delay, it will fail.
  connection {
    type = "ssh"
    host = self.public_ip
    user = "ec2-user"
    // note: connection use private key to decryption ssh connection
    private_key = file(var.private_key_location)
  }

/*
  // Terraform 会按照resource 里写的顺序执行 provisioner。"file","remote-exec"是Terraform内置provisioner插件的类型标识，不能改
  provisioner "file" {   // file的用途是将本地的entry-script.sh复制到ec2
    // 学习的话可以这么用terraform的内置变量path.root,如果在module的话,用path.module
    source = "${path.root}/script/entry-script.sh"  
    destination = "/home/ec2-user/aws-entry-script.sh"
  }

  provisioner "remote-exec" {
    // 执行上传到ec2后命名为aws-entry-script.sh脚本
    inline = [ 
      "cd /home/ec2-user",
      "bash aws-entry-script.sh"
     ]
  }
*/

/*
  provisioner "remote-exec" {
    # inline = [ 
    #   "export ENV=dev",
    #   "mkdir newidr"
    #  ]
    // 如果只是执行本地的这个.sh文件，script = "xxx.sh" 会自动把本地脚本上传到远程临时目录，然后执行。
    script = "./script/entry-script.sh"
    // 或者执行多个本地sh脚本，本质是将这些脚本上传到ec2的临时目录/tmp/,然后执行完成后删除脚本
    # scripts = ["a.sh", "b.sh"]
  }
*/

/* 
  //案例：通过本地写好的entry-script.sh脚本给ec2安装docker
  provisioner "remote-exec" {
    script = "./script/entry-script.sh"
  }

  // 然后将本地写好应用的docker-compose(多个文件)通过"file"来拷贝到用户目录下的app目录里
  provisioner "file" {
    source      = "app/"
    destination = "/home/ec2-user/app"
  }

  // 最后使用"remote-exec"可以实现在远程的ec2去执行inline的命令
  provisioner "remote-exec" {
    inline = [
      "cd /home/ec2-user/app",
      "docker compose up -d"
    ]
  }

  // 但不推荐，更好的做法是就是用user-data
  user_data = file("./script/bootstrap.sh")
*/

  provisioner "local-exec" {
    command = "echo ${self.public_ip} > output_ip.txt"
  }


  tags = {
    Name = "${var.env_prefix}-myapp-server"
  }
}